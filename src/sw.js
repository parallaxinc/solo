/*
 *   TERMS OF USE: MIT License
 *
 *   Permission is hereby granted, free of charge, to any person obtaining a
 *   copy of this software and associated documentation files (the "Software"),
 *   to deal in the Software without restriction, including without limitation
 *   the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *   and/or sell copies of the Software, and to permit persons to whom the
 *   Software is furnished to do so, subject to the following conditions:
 *
 *   The above copyright notice and this permission notice shall be included in
 *   all copies or substantial portions of the Software.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFINGEMENT. IN NO EVENT SHALL
 *   THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *   DEALINGS IN THE SOFTWARE.
 */

/*
 * This file is appended to the service worker script generated by Webpack.
 * The WorkboxWebpackPlugin plugin InjectManifest() call generates the route
 * and cache configuration and also populates the pre-cache list with the
 * generated hash bundled names of assets.
 *
 */

// import { CacheableResponsePlugin } from "workbox-cacheable-response";
// import { ExpirationPlugin } from "workbox-expiration";
// import { precacheAndRoute, cleanupOutdatedCaches, createHandlerBoundToURL } from "workbox-precaching";
import {registerRoute} from "workbox-routing";
import {NetworkFirst, NetworkOnly, StaleWhileRevalidate, CacheFirst} from "workbox-strategies";
import {precacheAndRoute} from 'workbox-precaching';

// Enable debug mode during development
const DEBUG_MODE = location.hostname.endsWith(".app.local") || location.hostname === "localhost";

const cacheName = 'SoloCache_V1';
const SW_VERSION = '1.0.0';

precacheAndRoute(self.__WB_MANIFEST);

console.log(`Registering compiler route.`)
registerRoute(
    /http:\/\/solo.parallax.com/,
    new NetworkFirst({
      cacheName: 'solo-page-cache',
    })
);


// Listen for the 'message' event type, used by PWA.
self.addEventListener('message', (event) => {
  if (event.data) {
    switch (event.data.type) {
      case 'GET_VERSION': // Send the application version to the client
        event.ports[0].postMessage(SW_VERSION);
        break;

      case 'SKIP_WAITING': // Install the latest available version right away
        event.ports[0].postMessage(SW_VERSION);
    }
  }
});


/**
 * Intercept calls to fetch()
 */
self.addEventListener('fetch', async (event) => {
  console.log(`[SW] Fetch: `, event);

  // Is this a request for an image?
  if (event.request.destination === 'image') {
    // Open the cache
    event.respondWith(caches.open(cacheName).then((cache) => {
      // Respond with the image from the cache or from the network
      return cache.match(event.request).then((cachedResponse) => {
        return cachedResponse || fetch(event.request.url).then((fetchedResponse) => {
          // Add the network response to the cache for future visits.
          // Note: we need to make a copy of the response to save it in
          // the cache and use the original as the request response.
          cache.put(event.request, fetchedResponse.clone());

          // Return the network response
          return fetchedResponse;
        });
      });
    }));
    // } else {
    //   return;
  }
});


// registerRoute(matchCb, handlerCb, 'POST');
// registerRoute(new RegExp('http:/+5001/single/prop-c/compile'), pwaRouteCompile, 'POST');


// const divInstall = document.getElementById('installContainer');
// const butInstall = document.getElementById('butInstall');


self.addEventListener('install', (event) => {
  console.log(`Event: ${event.type}`)
  console.log(`The PWA app is installing...`);
});


self.addEventListener('activate', (event) => {
  console.log(`Event: ${event.type}`)
  console.log(`The PWA app is activating...`);
});




/**
 * Root-level service worker
 */
// const initServiceWorker = () => {
//   if ('serviceWorker' in navigator) {
//     // Add listener for PWA installation prompts
//     pwaBeforeInstall();
//
//     console.log(`Preparing to load service worker`);
//     // Register the service worker
//     window.addEventListener('load', () => {
//       console.log(`Launching service worker`);
//       navigator.serviceWorker.register('/serviceWorker.js')
//           .then((registration) => {
//             console.log(`Service worker is registered in scope: ${registration.scope}`);
//           })
//           .catch((err) => {
//             console.log(`Service worker not loaded: ${err.message}`);
//           });
//     });
//   } else {
//     console.log('Service Worker is not supported.');
//   }
// }
//

